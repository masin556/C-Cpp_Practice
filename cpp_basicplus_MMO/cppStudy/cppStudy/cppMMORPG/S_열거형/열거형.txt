
const int SCISSORS = 1; 
const int ROCK = 2; 
const int PAPER = 3; 

상수이긴 한데 따로따로 노는 느낌?

경우에 따라 값이 늘어날 수 있다. 
일종의 버프 목록을 상수로 만들고자 하면.

스턴 공중부양 등등 하나하나 const를 붙여서 만들어주면 부담된다. 
또한 따로 관리되어 좋지 않다.

하나의 세트로 관리하는 것
= 열거형 enum을 사용할 수 있다. 

enum
{
	ENUM_SICSSORS,
	ENUM_ROCK,
	ENUM_PAPER
};

위처럼 하나로 관리.

const는 초기값을 무조건 넣어줘야 하는데. = 1;
enum값은 기본적으로 숫자를 지정하지 않을 경우 
첫 값은 0부터 시작한다. 

이미 해당 값에 = 0; 이 들어간것

그 다음 값들은 이전 값에서 +1 을 더한값 


ex)

enum
{
	ENUM_SICSSORS,
	ENUM_ROCK,
	ENUM_PAPER
};

예를들어 SICSSROS가 = 5 라면 
ROCK은 6 
PAPER는 7이 된다. 

enum의 대표 이름을 정해줄 수 있다. 

enum ENUM_SRP
{
	ENUM_SICSSORS,
	ENUM_ROCK,
	ENUM_PAPER
};

각자의 값을 설정 가능 

const 자료형 방법과 
enum을 사용하는 차이가 있다

ASSEMBLY 에서 보면 
const의 경우 메모리에 올라가 있거나 없거나 하는경우가 있다.
주소값을 보면 주소값에 안올라와 있다.

함수내부에 auto a = &SCISSORS라고 올린다면
주소를 보면 주소가 잡혀있다. 

함수 전역에서 쓰이거나. 지역에 따라 다르다.
함수 내부에 쓰이면 스택에 쓰이게 된다.

const int사용시 경우에 따라 컴파일러가 최적화가 가능하면 메모리에 안올리고도 
123으로 대체하겠지만. 함수 내부에 올려 스택에 올리거나 뭐 전역에 올려도 
주소를  참조 한다면 치환 되지 않고 실질적으로 변수들이 메모리에 올라가
낭비를 일으킨다.

enum의 경우
컴파일하는 단계에서 완벽히 바꿔치기 된다.
값 명이 눈으로 보이나. 실제적으로는 1 2 3 등의 값만 들어가게 된다. 


const 를 사용하는 경우 완전히 안좋은 것만은 아니다. 

-----------------------------

C++11에서는 enum class같은 것도 있다..


#define 으로 사용하는법

// #이 붙은것은 전처리 지시문 
//전처리 : 빌드할 때 전처리 단게=> 컴파일단계 같이 나눠지는데 
//컴파일이 통역사 역할 
//기초 작업을 전처리에서 먼저 해주고, 
컴파일이 끝난 후 최종결과물을 엮어서 하는 것이 링크 

#define DEFINE_SCISSORS 1


#include <iostream>

컴파일 단계로 넘어가기전에 iostream 파일을 찾아서 해당 내용을 복붙하라는 의미가 된다.

F12키를 누르면 해당 iostream 파일내용을
우리들의 소스에 사용할 수 있게 긁어준 느낌 복붙?


#define도 DEFINE_SCISSORS라는 것이 문구가 나오면 1 이 들어가면 1이라는 값으로 대체해달라는 의미

enum은 정수만 사용하는 것들이 있었는데
define의 경우 꼭 정수만 사용한다는 보장은 없다.
그냥 코드 자체로 매크로화 시키기 때문에

예시로 
#define DEFINE_TEST cout << "Hello world!" << endl;

이형식으로 
int main()
{
	DEFINE_TEST; 하게된다면 
}

해당 코드가 고대로 바꿔치기 되어 사용되어진다. 

Hello world!가 출력문으로 들어오게 된다. 


코드를 바꿔치기 하는 개념이다. 

일반적인 C++에서 Define을 사용할 수 있지만.
마구 남용하면 생각보다 별로 안좋을 수 있다. 


#define DEFINE_SCISSORS 1+2 라고 했을때 3이될 거 같지만..

int result = DEFINE_SCISSORS  * 2; 를 했을때 6일 것 같지만. 

5가 나오게 된다..

이것은 

DEFINE_SCISSORS라는 곳에 해당 글자 로 고대로 바꿔주는 것이다. 

int result = 1+2 * 2 이런식으로 


컴파일 단계에서 분석하여 우선순위가 + 보다 * 가 우선이기에 5가 된다. 

그래서 define보다 enum 이나 const같은 것을 먼저 사용하는 편이 좋다. 

전처리 단계가 끝나면 define_SCISSORS가 완전히 날라간다. 
디버깅 할때 남아있지 않는 현상이 있다. 

DEFINE_TEST가 디버깅 했을때 
전처리 단계에서 실행되었다는 것은 이미 컴파일-> 링크까지 다 통과가 되었다는 것이다. 
DEFINE_TEST 값은 더이상 존재하지 않고,  cout << "Hello world!" << endl;만 존재하게 된다. 

즉 버그가 생겼을때 대응하기 힘들 수 있다. 



그래서 enum값을 하게 된다면 

해당 값이 바뀌어 있다해도 어떤값을 의미하는지 힌트가 출력되어 디버깅이 더 쉽다. 



반복적인 코드를 만들때에는 매크로로 만들면 좋으나. 
상수를 만들때 enum또는 const 자료형 과 같이 좋은 것들은 있는데.
굳이 그것들을 두고 define을 사용하는 것은 별로 좋지 않다. 

enum 또는 const 많이 사용

enum이 우선순위로 생각하자




