/*비트 연산과 비트플래그*/
#include <iostream>
using namespace std;

// 주제 : 데이터 연산

// 비트 플래그
unsigned char flag; // 부호를 없애야 >> 하더라도 부호비트가 딸려오지 않는다.

int main()
{
#pragma region 비트연산
	// 언제 필요한가? (많이 없긴하다)
	// 종종 비트 단위의 조작이 필요할 때
	// 게임서버 ID를 만들거나. 꾸겨서 넣다보니 비트 조작이 필요
	// - 대표적으로 BitFlag

	// 비트연산자 어떤 숫자에 대해 비트단위로 세밀하게 조작할 때.
	// 특정 비트를 끄거나 켜거나 하는

	// ~ bitwise not
	// : 단일 숫자의 모든 비트를 대상으로 0은 1, 1은 0으로 (비트를 뒤집어준다)

	// & bitwise and
	// : 두 숫자의 모든 비트 쌍을 대상으로, (즉 두 비트 사이에 값으로 판단 1 0 = 0, 1 1 = 1 같은 식)

	// | bitwise or
	// : 두 숫자 사이에 or문 ( 0 0 = 0, 1 0 = 1, 1 1 = 1 과 같은형태)

	// ^ bitwise xor
	// : 두 숫자의 모든 비트 쌍을 대상으로 xor를 한다 ( 0 0 = 0 , 1 0 = 1, 1 1 = 0, 같으면 싫다 같은)
	// 숫자를 두번 xor 하면 원복된다 (암호화 할 때 유용?)

	// << 비트 좌측 이동
	// : 비트열을 N만큼 왼쪽으로 이동
	// 왼쪽의 넘치는 N개의 비트는 버린다. 새로 생성되는 N개의
	// *2를 할 때 자주 보이는 패턴 (비트당 하나씩 2의 제곱 되기 때문)

	// >> 비트 우측 이동
	// : 좌측보다 까다로움 : 비트열을 N만큼 오른쪽으로 이동
	// 오른쪽에 넘치는 N개의 비트는 버린다.
	// 왼쪽 생성되는 N개 비트는? 부호가 있냐 없느냐에 따라 차이가 난다.
	// - 부호 비트가 존재할 경우 부호 비트를 따라간다 (부호 있는 정수라면 이 부분을 유의하자)
	// - 아니라면 0이다.


	// 실습
	// 예시 ) 이상상태 비트플래그가 아닌 bool값으로 사용할 수도 있다. 그러나 만약 상태가 여러가지 30몇개면 엄청 많아질 것이다.
	// 0b0000 [무적][변이][스턴][공중부양]
	// 첫번째 비트 0001 공중부양, 0010 스턴, 0100 변이, 1000 무적, 1100 무적+변이
	// 각 비트에 의미를 부여할 수 있다.
	// bool 노가다를 막을 수 있다.


	/*무적상태*/
	flag = (1 << 3);

	/* 변이 상태를 추가 (무적 + 변이) */
	// flag |= 4; // 이것도 가능하겠지만.
	flag |= (1 << 2);

	// 무적인지 확인하고 싶다? (다른 상태는 관심 없음)
	// bitmask : 필요 없는 부분은 가린다.
	bool bInvisible = ((flag & (1 << 3)) != 0);

	// 무적이거나 스턴 상태인지 확인하고 싶다면?
	bool bStunOrInvicible = ((flag & 0b1010) != 0);


#pragma endregion


}