함수 내부에 동일한 똑같은 이름을 붙일 수 없다.

1. 중괄호를 함수 내부에 하나더 만들어서 중괄호 내부에 벗어나면 사용할 수 없다 
	ex1)
	int main()
	{
		{
			int hp = 3;
			cout << hp << endl;
		}

		int hp = 100;
	}

2.지역변수도 전역변수도 똑같이 사용하는 전제하에 값은 다르게 하고 빌드해도 이상없다. 
	지역변수가 먼저 출력되고 
	
	전역 변수로 사용할 것을 이름을 컨벤션을 만들어서 사용한다. 

	ex2) 
	int G_hp = 3;  //이런식으로 전역을 global로 




2) 연산자 우선순위

	짝수를 구한다 했을때 
	bool isEven = (hp % 2 == 0);
	2로 나눈 나머지가 0이라면 짝수
	연산자 우선순위에 의해 이것은 상관없지만. 혹여나 무엇부터 우선으로 할지 정한다면
	(   ) 괄호를 줘서 안전하게 하는 방법도 있다. 연산자 우선순위가 헷갈린다면 저렇게 할 수 있다. 

	((hp % 2) == 0) 이런식 



3) 타입 변환
	
	작은 것 다양한 정수형 이나 실수형 등을 바꿔서 사용할 것이다. 
	이것을 casting이라고 한다. 
	short hp2 = (short)hp;
	float hp3 = (flaot)hp;
	unsigned int hp4 = (unsigned)hp; 이런 느낌 

	C++ 은 이것을 제거하고 자동으로 처리해준다. 
	short hp2 = hp;
	float hp3 = hp;
	unsigned int hp4 = hp;

	바구니를 교체할 때 어떤 행동이 일어날까? 

	작은 바구니에 있던것을 큰 바구니로 옮기는 것은 괜찮은데
	큰바구니 있던 것을 작은 바구니로 옮기는 것은 힘들 것이다. 




4) 사칙연산
	//곱셈 시 오버플로우에 주의해야한다. 
	너무 큰값을 곱하면 int의 범위를 초과해서 나올 수 있고 깨질 수 있다. 

	1. __int64 * int = int int64를 사용해서 작업을 하거나
	2. int 자체를 중간에 int64로 잘 변환해서 사용하거나 

	//나눗셈 시 
	 1, 0을 곱하였을 때 주의 
	 ex) 
		int maxHp = 10000;
		float ratio = hp / maxHp; 
		0을 나누기 하면 크래쉬가 난다. 


	2. 실수를 나누는
		int hp = 123;

		int maxHp = 1000;
		float ratio hp / maxHp; //예측값 : 0.123

		실제 실행시 : 0이라는 값이 출력된다. 
		C++은 정수끼리 나누면 
		int / int = int 정수로 생각한다. 그래서 0.123에서 123은 날라가고 0이 나온다. 

		고친다하면 두개중 하나는 실수로 만들어야 한다. 
		
		그래서 2개중 하나를 강제로 float으로 변환 

		float ratio hp / (float)maxHp; 이런식으로 바꿔준다. 


